// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.0
//   protoc               v6.33.4
// source: zylance/lib/Stream.proto

/* eslint-disable */

export const protobufPackage = "zylance.contract";

/**
 * Event emitted by the sender, to let the receiver know a stream is being sent.
 * Data will be passed in subsequent StreamPayload messages.
 */
export interface StreamStartEvt {
  streamId: string;
}

/** Event emitted by the receiver, to say that it's ready to receive stream data. */
export interface StreamListenEvt {
  streamId: string;
}

/** Event emitted by either party to indicate that the stream should be cancelled. */
export interface StreamCancelledEvt {
  streamId: string;
  reason: string;
  dataJson?: string | undefined;
}

/** Event emitted by either party to indicate that an error has occurred with the stream. */
export interface StreamErrorEvt {
  streamId: string;
  reason: string;
  details: string;
}

function createBaseStreamStartEvt(): StreamStartEvt {
  return { streamId: "" };
}

export const StreamStartEvt: MessageFns<StreamStartEvt> = {
  fromJSON(object: any): StreamStartEvt {
    return {
      streamId: isSet(object.streamId)
        ? globalThis.String(object.streamId)
        : isSet(object.stream_id)
        ? globalThis.String(object.stream_id)
        : "",
    };
  },

  toJSON(message: StreamStartEvt): unknown {
    const obj: any = {};
    if (message.streamId !== "") {
      obj.streamId = message.streamId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamStartEvt>, I>>(base?: I): StreamStartEvt {
    return StreamStartEvt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamStartEvt>, I>>(object: I): StreamStartEvt {
    const message = createBaseStreamStartEvt();
    message.streamId = object.streamId ?? "";
    return message;
  },
};

function createBaseStreamListenEvt(): StreamListenEvt {
  return { streamId: "" };
}

export const StreamListenEvt: MessageFns<StreamListenEvt> = {
  fromJSON(object: any): StreamListenEvt {
    return {
      streamId: isSet(object.streamId)
        ? globalThis.String(object.streamId)
        : isSet(object.stream_id)
        ? globalThis.String(object.stream_id)
        : "",
    };
  },

  toJSON(message: StreamListenEvt): unknown {
    const obj: any = {};
    if (message.streamId !== "") {
      obj.streamId = message.streamId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamListenEvt>, I>>(base?: I): StreamListenEvt {
    return StreamListenEvt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamListenEvt>, I>>(object: I): StreamListenEvt {
    const message = createBaseStreamListenEvt();
    message.streamId = object.streamId ?? "";
    return message;
  },
};

function createBaseStreamCancelledEvt(): StreamCancelledEvt {
  return { streamId: "", reason: "", dataJson: undefined };
}

export const StreamCancelledEvt: MessageFns<StreamCancelledEvt> = {
  fromJSON(object: any): StreamCancelledEvt {
    return {
      streamId: isSet(object.streamId)
        ? globalThis.String(object.streamId)
        : isSet(object.stream_id)
        ? globalThis.String(object.stream_id)
        : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      dataJson: isSet(object.dataJson)
        ? globalThis.String(object.dataJson)
        : isSet(object.data_json)
        ? globalThis.String(object.data_json)
        : undefined,
    };
  },

  toJSON(message: StreamCancelledEvt): unknown {
    const obj: any = {};
    if (message.streamId !== "") {
      obj.streamId = message.streamId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.dataJson !== undefined) {
      obj.dataJson = message.dataJson;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamCancelledEvt>, I>>(base?: I): StreamCancelledEvt {
    return StreamCancelledEvt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamCancelledEvt>, I>>(object: I): StreamCancelledEvt {
    const message = createBaseStreamCancelledEvt();
    message.streamId = object.streamId ?? "";
    message.reason = object.reason ?? "";
    message.dataJson = object.dataJson ?? undefined;
    return message;
  },
};

function createBaseStreamErrorEvt(): StreamErrorEvt {
  return { streamId: "", reason: "", details: "" };
}

export const StreamErrorEvt: MessageFns<StreamErrorEvt> = {
  fromJSON(object: any): StreamErrorEvt {
    return {
      streamId: isSet(object.streamId)
        ? globalThis.String(object.streamId)
        : isSet(object.stream_id)
        ? globalThis.String(object.stream_id)
        : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      details: isSet(object.details) ? globalThis.String(object.details) : "",
    };
  },

  toJSON(message: StreamErrorEvt): unknown {
    const obj: any = {};
    if (message.streamId !== "") {
      obj.streamId = message.streamId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.details !== "") {
      obj.details = message.details;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamErrorEvt>, I>>(base?: I): StreamErrorEvt {
    return StreamErrorEvt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamErrorEvt>, I>>(object: I): StreamErrorEvt {
    const message = createBaseStreamErrorEvt();
    message.streamId = object.streamId ?? "";
    message.reason = object.reason ?? "";
    message.details = object.details ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
